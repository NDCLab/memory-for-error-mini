# This script will load, and organize the pavlovia data. Then, computes measures of interest.
# For each participant, a single, new, organized csv file that has all the necessary information will be generated.
# Author: Kianoosh Hosseini at NDCLab @FIU (https://Kianoosh.info; https://NDClab.com)
# Last Update: 2023-02-23 (YYYY-MM-DD)

library(tidyverse)
library(dplyr)
library(stringr)
library(psycho)

#Working directory should be the Psychopy experiment directory.
proje_wd <- "/Users/kihossei/Documents/GitHub/memory-for-error-mini/materials/mini_mfe"
setwd(proje_wd)

input_raw_path <- paste(proje_wd, "data", sep ="/", collapse = NULL) # input data directory
input_organized_path <- paste(proje_wd, "csv_output", sep ="/", collapse = NULL) # input directory for data files generated by the organizer script!
output_path <- paste(proje_wd, "stat_output", sep ="/", collapse = NULL) # output directory
proc_fileName <- "processed_data_mini_mfe_Proj.csv" # output filename
flanker_csv_fileName <- "_mini_mfe_flankerDat.csv" # each output csv file will have this on its filename
surprise_csv_fileName <- "_mini_mfe_surpriseDat.csv" # each output csv file will have this on its filename


## creating a list of all raw data csv files in the input folder.
raw_datafiles_list <- c() # an empty list that will be filled in the next "for" loop!
csvSelect <- list.files(input_raw_path, pattern = ".csv") # listing only csv files
for (i in 1:length(csvSelect)){
  temp_for_file <- ifelse (str_detect(csvSelect[i], "face_flanker_v1", negate = FALSE), 1, 0)
  if (temp_for_file == 1){
    temp_list <- csvSelect[i]
    raw_datafiles_list <- c(raw_datafiles_list, temp_list)
  }
}
# Creating the main empty dataframe that will be filled with the data from the loop below:
main_df <- setNames(data.frame(matrix(ncol = 57, nrow = 0)), c("participant_id", "congAcc", "incongAcc",
                                                               "incongruent_dat_meanRT", "errorDat_meanRT", "congruent_dat_meanRT", "corrDat_meanRT",
                                                               "congCorr_meanRT", "incongCorr_meanRT", "congCorr_logMeanRT",
                                                               "congErr_meanRT", "incongErr_meanRT", "congErr_logMeanRT", "incongErr_logMeanRT",
                                                               "incongCorr_logMeanRT", "flankEff_meanACC", "flankEff_meanRT", "flankEff_logMeanRT",
                                                               "reported_errors", "committed_errors", "memoryBias_score", "overall_hitRate", "error_hitRate",
                                                               "correct_hitRate", "post_correct_hitRate", "pre_correct_hitRate",
                                                               "pre_error_hitRate", "post_error_hitRate",
                                                               "num_pre_correctFaces_reported_new", "num_pre_correctFaces_reported_old",
                                                               "num_pre_errorFaces_reported_new", "num_pre_errorFaces_reported_old",
                                                               "num_post_correctFaces_reported_new", "num_post_correctFaces_reported_old",
                                                               "num_post_errorFaces_reported_new", "num_post_errorFaces_reported_old",
                                                               "num_incong_correctFaces_reported_new", "num_incong_correctFaces_reported_old",
                                                               "num_incong_errorFaces_reported_new", "num_incong_errorFaces_reported_old",
                                                               "hit_num", "false_alrams_num", "miss_num", "corr_rej_num", "incong_error_hit_num",
                                                               "incong_pre_error_hit_num", "incong_post_error_hit_num", "incong_correct_hit_num",
                                                               "incong_pre_correct_hit_num", "incong_post_correct_hit_num", "incong_error_miss_num",
                                                               "incong_pre_error_miss_num", "incong_post_error_miss_num", "incong_correct_miss_num",
                                                               "incong_pre_correct_miss_num", "incong_post_correct_miss_num", "num_post_error_faces"))

# Counters for the number of excluded people based on each criterion
num_of_participants_removed_based_on_memory_surp_trial_removal <- 0 # Will be updated in the loop below
num_of_participants_removed_based_on_accuracy <- 0 # Will be updated in the loop below
num_of_participants_removed_based_on_incong_error_num <- 0 # Will be updated in the loop below
num_participants_removed_based_on_num_incong_error_faces_in_memory_surp <- 0 # Will be updated in the loop below

# Looping over all participants
for (subject in 1:length(raw_datafiles_list)){
  #for this participant, find the raw csv file
  psychopy_file <- paste(input_raw_path,raw_datafiles_list[subject], sep = "/", collapse = NULL)

  #read in the data for this participant, establish id, and remove extraneous variables
  psychopyDat <- read.csv(file = psychopy_file, stringsAsFactors = FALSE, na.strings=c("", "NA"))
  participant_id <- psychopyDat$id[1]

  # Load this participant's flanker and surprise data frames
  flanker_name <- paste0(participant_id, flanker_csv_fileName, sep = "", collapse = NULL)
  surprise_name <- paste0(participant_id, surprise_csv_fileName, sep = "", collapse = NULL)
  flanker_df <- read.csv(file = paste(input_organized_path, flanker_name, sep = "/", collapse = NULL), stringsAsFactors = FALSE, na.strings=c("", "NA"))
  surprise_df <- read.csv(file = paste(input_organized_path, surprise_name, sep = "/", collapse = NULL), stringsAsFactors = FALSE, na.strings=c("", "NA"))

  # removing participants based on whether they just pressed the keys without actually paying attention to the task.
  # We check this by "keep_surp_memory_trial_based_on_rt" and "keep_surp_friendly_trial_based_on_rt" variables
  # in the surprise_df data frame. O means that they have responded faster than 200 ms during the given trial
  # and therefore, we need to remove that surprise trial.
  # In this study, we will remove people based on the surprise memory task not surprise friendly task.
  # If more than 20% of surprise trials are removed, we exclude that participant.
  number_of_removed_trials_in_the_memory_surp <- nrow(surprise_df) - (sum(surprise_df$keep_surp_memory_trial_based_on_rt))
  number_of_faces_in_surp_memory_task <- nrow(surprise_df)
  twenty_percent_threshold <- round(0.2 * number_of_faces_in_surp_memory_task)

  if (number_of_removed_trials_in_the_memory_surp <= twenty_percent_threshold){ # Participants who have less than twenty_percent_threshold surprise
    # trials removed, will be included.

    # Check to see if this participant has the flanker accuracy above 60%
    if (mean(as.numeric(flanker_df$current_trial_accuracy)) >= 0.6){

      # check to see if the participant has at least 8 legit incongruent errors or not.
      incong_flankerDat <- filter(flanker_df, current_trial_congruency == 0)
      cong_flankerDat <- filter(flanker_df, current_trial_congruency == 1)
      error_incong_flankerDat <- filter(incong_flankerDat, current_trial_accuracy == 0)
      legit_error_incong_flankerDat <- filter(error_incong_flankerDat, current_trial_legitResponse == 1)
      if (nrow(legit_error_incong_flankerDat) >= 8 ){

        # Checking to see if there are at least 6 incongruent error faces in the surprise_df of this participant.
        # First we need to remove the trials that are marked based on rt!
        surprise_df <- filter(surprise_df, keep_surp_memory_trial_based_on_rt == 1)
        num_incong_error_faces_in_surp <- 0
        # Counting the number of legit incong error faces available in surprise_df!
        for (rr in 1:nrow(legit_error_incong_flankerDat)){
          temp_face <- legit_error_incong_flankerDat$current_trial_face[rr]
          temp_for_surp <- filter(surprise_df, face == temp_face)
          errorFace_exist_in_surpDat <- ifelse(nrow(temp_for_surp) == 1, 1,0)
          if (errorFace_exist_in_surpDat == 1){
            num_incong_error_faces_in_surp <- num_incong_error_faces_in_surp + 1
          }
        } # Closing the loop that counts the number of incong error faces available in surprise_df!
        if (num_incong_error_faces_in_surp >= 8){

          incongAcc <- mean(as.numeric(incong_flankerDat$current_trial_accuracy))
          congAcc <- mean(as.numeric(cong_flankerDat$current_trial_accuracy))

          #


          # subset the data for correct and error trials, separately for congruent and incongruent trials, creating new data frames for each
          corrDat <- flanker_df[flanker_df$current_trial_accuracy == 1,]
          corrDat_meanRT <- mean(corrDat$current_trial_rt, na.rm = TRUE)

          congruent_dat <- flanker_df[flanker_df$current_trial_congruency == 1,]
          congruent_dat_meanRT <- mean(congruent_dat$current_trial_rt, na.rm = TRUE)

          cong_corrDat <- corrDat[corrDat$current_trial_congruency == 1,]
          incong_corrDat <- corrDat[corrDat$current_trial_congruency == 0,]

          errorDat <- flanker_df[flanker_df$current_trial_accuracy == 0,]
          errorDat_meanRT <- mean(errorDat$current_trial_rt, na.rm = TRUE)

          incongruent_dat <- flanker_df[flanker_df$current_trial_congruency == 0,]
          incongruent_dat_meanRT <- mean(incongruent_dat$current_trial_rt, na.rm = TRUE)


          cong_errorDat <- errorDat[errorDat$current_trial_congruency == 1,]
          incong_errorDat <- errorDat[errorDat$current_trial_congruency == 0,]
          #for correct trials, compute mean RT (raw and log-corrected)
          congCorr_meanRT <- mean(cong_corrDat$current_trial_rt, na.rm = TRUE)
          incongCorr_meanRT <- mean(incong_corrDat$current_trial_rt, na.rm = TRUE)

          congErr_meanRT <- mean(cong_errorDat$current_trial_rt, na.rm = TRUE)
          incongErr_meanRT <- mean(incong_errorDat$current_trial_rt, na.rm = TRUE)

          congCorr_logMeanRT <- mean(log((1+cong_corrDat$current_trial_rt)), na.rm = TRUE)
          incongCorr_logMeanRT <- mean(log((1+incong_corrDat$current_trial_rt)), na.rm = TRUE)

          congErr_logMeanRT <- mean(log((1+cong_errorDat$current_trial_rt)), na.rm = TRUE)
          incongErr_logMeanRT <- mean(log((1+incong_errorDat$current_trial_rt)), na.rm = TRUE)

          # compute flanker-effect scores for accuracy, RT, log-RT
          flankEff_meanACC <- incongAcc - congAcc
          flankEff_meanRT <- incongCorr_meanRT - congCorr_meanRT
          flankEff_logMeanRT <- incongCorr_logMeanRT - congCorr_logMeanRT

          #
          # number of committed errors in the flanker task
          committed_errors <- nrow(errorDat)
          # number of reported errors
          psychopyDatTrim <- psychopyDat[("textbox_2.text")] # stores the number of reported errors by subjects
          reported_errors <- subset(psychopyDatTrim, complete.cases(psychopyDatTrim$textbox_2.text))
          reported_errors <- reported_errors$textbox_2.text # number of reported errors by participants
          reported_errors <- str_extract_all(reported_errors, '\\d+\\.?\\d*') # to extract all sequences of digits from the input string
          # There was a participant who had reported 70/100. values 70 and 100. To solve this issue, I replace this kind of values with NAs!
          if (length(reported_errors) == 0){ # there is no reported errors
            reported_errors <- NA
            memoryBias_score <- NA
          } else {
            reported_errors <- parse_number(reported_errors[[1]]) # in cases like 70/100, we will have 70 100 at this stage. So, length(reported_errors) will
            # higher than 1.
            if (length(reported_errors) > 1){ # In case they have reported sth like 70/100
              reported_errors <- NA
              memoryBias_score <- NA
            } else if (length(reported_errors) == 1){
              reported_errors <- reported_errors[1]
              memoryBias_score <- ((reported_errors - committed_errors)/ reported_errors) # percent bias score calculation
            }
          }



          ### number of incong error faces identified as old
          num_incong_errorFaces_reported_old <- 0 # this is the number of incongruent error faces that they report as OLD and will be updated in the loop below:
          for (iii in 1:nrow(error_incong_flankerDat)){
            if (error_incong_flankerDat$current_trial_legitResponse[iii] == 1){ # if this trial is legit
              temp_face_from_flanker <- error_incong_flankerDat$current_trial_face[iii]
              temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
              if (nrow(temp_face_row_in_surp) == 1){ # if old incong error face exist in the surprise_df
                if (temp_face_row_in_surp$identified_as_new == 0){ # the face is identified as old
                  num_incong_errorFaces_reported_old <- num_incong_errorFaces_reported_old + 1 # The number of incongruent error faces that they report as OLD
                }
              }
            }
          } # closing the loop over error incong flankerDat

          ### number of incong error faces identified as new
          num_incong_errorFaces_reported_new <- 0 # this is the number of incongruent error faces that they report as new and will be updated in the loop below:
          for (iii in 1:nrow(error_incong_flankerDat)){
            if (error_incong_flankerDat$current_trial_legitResponse[iii] == 1){ # if this trial is legit
              temp_face_from_flanker <- error_incong_flankerDat$current_trial_face[iii]
              temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
              if (nrow(temp_face_row_in_surp) == 1){ # if old incong error face exist in the surprise_df
                if (temp_face_row_in_surp$identified_as_new == 1){ # the face is identified as New
                  num_incong_errorFaces_reported_new <- num_incong_errorFaces_reported_new + 1 # The number of incongruent error faces that they report as New
                }
              }
            }
          } # closing the loop over error incong flankerDat


          ### number of incong correct faces identified as old
          num_incong_correctFaces_reported_old <- 0 # this is the number of incongruent correct faces that they report as Old and will be updated in the loop below:
          for (iii in 1:nrow(incong_corrDat)){
            if (incong_corrDat$current_trial_legitResponse[iii] == 1){ # if this trial is legit
              temp_face_from_flanker <- incong_corrDat$current_trial_face[iii]
              temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
              if (nrow(temp_face_row_in_surp) == 1){ # if old incong correct face exist in the surprise_df
                if (temp_face_row_in_surp$identified_as_new == 0){ # the face is identified as Old
                  num_incong_correctFaces_reported_old <- num_incong_correctFaces_reported_old + 1 # The number of incongruent correct faces that they report as Old
                }
              }
            }
          } # closing the loop over correct incong flankerDat

          ### number of incong correct faces identified as new
          num_incong_correctFaces_reported_new <- 0 # this is the number of incongruent correct faces that they report as new and will be updated in the loop below:
          for (iii in 1:nrow(incong_corrDat)){
            if (incong_corrDat$current_trial_legitResponse[iii] == 1){ # if this trial is legit
              temp_face_from_flanker <- incong_corrDat$current_trial_face[iii]
              temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
              if (nrow(temp_face_row_in_surp) == 1){ # if old incong correct face exist in the surprise_df
                if (temp_face_row_in_surp$identified_as_new == 1){ # the face is identified as New
                  num_incong_correctFaces_reported_new <- num_incong_correctFaces_reported_new + 1 # The number of incongruent correct faces that they report as New
                }
              }
            }
          } # closing the loop over correct incong flankerDat
          # Pre and post trials must be correct while they can be either incongruent or congruent.
          ### number of post error faces identified as old
          num_post_errorFaces_reported_old <- 0 # this is the number of post error faces that they report as OLD and will be updated in the loop below:
          for (iii in 1:nrow(error_incong_flankerDat)){
            if (!is.na(error_incong_flankerDat$post_trial_legitResponse[iii])){ # In case current trial is the last trial in the block, post/pre_trial will be NA! So, this condition will prevent from errors!
              if (error_incong_flankerDat$post_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (error_incong_flankerDat$post_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- error_incong_flankerDat$post_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong error face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 0){ # the face is identified as old
                      num_post_errorFaces_reported_old <- num_post_errorFaces_reported_old + 1 # The number of incongruent error faces that they report as OLD
                    }
                  }
                }
              }
            }
          } # closing the loop


          ### number of incong post error faces identified as new
          num_post_errorFaces_reported_new <- 0 # this is the number of post error faces that they report as New and will be updated in the loop below:
          for (iii in 1:nrow(error_incong_flankerDat)){
            if (!is.na(error_incong_flankerDat$post_trial_legitResponse[iii])){
              if (error_incong_flankerDat$post_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (error_incong_flankerDat$post_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- error_incong_flankerDat$post_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong error face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 1){ # the face is identified as New
                      num_post_errorFaces_reported_new <- num_post_errorFaces_reported_new + 1 # The number of incongruent error faces that they report as New
                    }
                  }
                }
              }
            }
          } # closing the loop

          ### number of incong post correct faces identified as old
          num_post_correctFaces_reported_old <- 0 # this is the number of post correct faces that they report as OLD and will be updated in the loop below:
          for (iii in 1:nrow(incong_corrDat)){
            if (!is.na(incong_corrDat$post_trial_legitResponse[iii])){
              if (incong_corrDat$post_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (incong_corrDat$post_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- incong_corrDat$post_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong correct face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 0){ # the face is identified as old
                      num_post_correctFaces_reported_old <- num_post_correctFaces_reported_old + 1 # The number of incongruent correct faces that they report as OLD
                    }
                  }
                }
              }
            }
          } # closing the loop

          ### number of incong post correct faces identified as new
          num_post_correctFaces_reported_new <- 0 # this is the number of post correct faces that they report as New and will be updated in the loop below:
          for (iii in 1:nrow(incong_corrDat)){
            if (!is.na(incong_corrDat$post_trial_legitResponse[iii])){
              if (incong_corrDat$post_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (incong_corrDat$post_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- incong_corrDat$post_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong correct face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 1){ # the face is identified as New
                      num_post_correctFaces_reported_new <- num_post_correctFaces_reported_new + 1 # The number of incongruent correct faces that they report as New
                    }
                  }
                }
              }
            }
          } # closing the loop

          ### number of incong pre error faces identified as old
          num_pre_errorFaces_reported_old <- 0 # this is the number of pre error faces that they report as OLD and will be updated in the loop below:
          for (iii in 1:nrow(error_incong_flankerDat)){
            if (!is.na(error_incong_flankerDat$pre_trial_legitResponse[iii])){
              if (error_incong_flankerDat$pre_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (error_incong_flankerDat$pre_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- error_incong_flankerDat$pre_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong error face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 0){ # the face is identified as old
                      num_pre_errorFaces_reported_old <- num_pre_errorFaces_reported_old + 1 # The number of incongruent error faces that they report as OLD
                    }
                  }
                }
              }
            }
          } # closing the loop

          ### number of incong pre error faces identified as new
          num_pre_errorFaces_reported_new <- 0 # this is the number of pre error faces that they report as New and will be updated in the loop below:
          for (iii in 1:nrow(error_incong_flankerDat)){
            if (!is.na(error_incong_flankerDat$pre_trial_legitResponse[iii])){
              if (error_incong_flankerDat$pre_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (error_incong_flankerDat$pre_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- error_incong_flankerDat$pre_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong error face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 1){ # the face is identified as New
                      num_pre_errorFaces_reported_new <- num_pre_errorFaces_reported_new + 1 # The number of incongruent error faces that they report as New
                    }
                  }
                }
              }
            }
          } # closing the loop


          ### number of incong pre correct faces identified as old
          num_pre_correctFaces_reported_old <- 0 # this is the number of pre correct faces that they report as OLD and will be updated in the loop below:
          for (iii in 1:nrow(incong_corrDat)){
            if (!is.na(incong_corrDat$pre_trial_legitResponse[iii])){
              if (incong_corrDat$pre_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (incong_corrDat$pre_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- incong_corrDat$pre_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong correct face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 0){ # the face is identified as old
                      num_pre_correctFaces_reported_old <- num_pre_correctFaces_reported_old + 1 # The number of incongruent correct faces that they report as OLD
                    }
                  }
                }
              }
            }
          } # closing the loop


          ### number of incong pre correct faces identified as new
          num_pre_correctFaces_reported_new <- 0 # this is the number of pre correct faces that they report as New and will be updated in the loop below:
          for (iii in 1:nrow(incong_corrDat)){
            if (!is.na(incong_corrDat$pre_trial_legitResponse[iii])){
              if (incong_corrDat$pre_trial_legitResponse[iii] == 1){ # if this trial is legit
                if (incong_corrDat$pre_trial_accuracy[iii] == 1){ #Pre and post trials must be correct while they can be either incongruent or congruent.
                  temp_face_from_flanker <- incong_corrDat$pre_trial_face[iii]
                  temp_face_row_in_surp <- filter(surprise_df, face == temp_face_from_flanker)
                  if (nrow(temp_face_row_in_surp) == 1){ # if old incong correct face exist in the surprise_df
                    if (temp_face_row_in_surp$identified_as_new == 1){ # the face is identified as New
                      num_pre_correctFaces_reported_new <- num_pre_correctFaces_reported_new + 1 # The number of incongruent correct faces that they report as New
                    }
                  }
                }
              }
            }
          } # closing the loop

          ########################## SIGNAL DETECTION THEORY ########################################
          # We make use of SDT in the surprise memory task.
          # OLD is our target.
          ###########################################################################################

          # Overall hits, misses, FAs, and Correct rejections regardless of errors and corrects.
          hit_num <- 0
          miss_num <- 0
          corr_rej_num <- 0 # Correct rejections number is the same for Errors, corrects as it is overall. It means they identify new faces as new!
          false_alrams_num <- 0

          for (surpTrial in 1:nrow(surprise_df)){
            if (surprise_df$is_new[surpTrial] == 0){ # The face is old
              if (surprise_df$identified_as_new[surpTrial] == 0) { # The old face is identified correctly as old
                hit_num <- hit_num + 1
              } else if (surprise_df$identified_as_new[surpTrial] == 1){ # The old face is identified incorrectly as new
                miss_num <- miss_num + 1
              }
            } else if (surprise_df$is_new[surpTrial] == 1){ # The face is new
              if (surprise_df$identified_as_new[surpTrial] == 0) { # The new face is identified incorrectly as old
                false_alrams_num <- false_alrams_num + 1
              } else if (surprise_df$identified_as_new[surpTrial] == 1){ # The new face is identified correctly as new
                corr_rej_num <- corr_rej_num + 1
              }
            }
          } # Closing the loop over surprise_df trials

          overall_hitRate <- (hit_num) / ((hit_num) + miss_num) # hit rate
          # False alaram numbers is the same for Error, and correct faces as it is the overall FA! I computed it above with "false_alrams_num" name.
          incong_error_hit_num <- num_incong_errorFaces_reported_old
          incong_error_miss_num <- num_incong_errorFaces_reported_new
          error_hitRate <- (incong_error_hit_num) / ((incong_error_hit_num) + incong_error_miss_num) # hit rate


          incong_correct_hit_num <- num_incong_correctFaces_reported_old
          incong_correct_miss_num <- num_incong_correctFaces_reported_new
          correct_hitRate <- (incong_correct_hit_num) / ((incong_correct_hit_num) + incong_correct_miss_num) # hit rate

          incong_post_correct_hit_num <- num_post_correctFaces_reported_old
          incong_post_correct_miss_num <- num_post_correctFaces_reported_new
          post_correct_hitRate <- (incong_post_correct_hit_num) / ((incong_post_correct_hit_num) + incong_post_correct_miss_num) # hit rate

          incong_pre_correct_hit_num <- num_pre_correctFaces_reported_old
          incong_pre_correct_miss_num <- num_pre_correctFaces_reported_new
          pre_correct_hitRate <- (incong_pre_correct_hit_num) / ((incong_pre_correct_hit_num) + incong_pre_correct_miss_num) # hit rate

          incong_pre_error_hit_num <- num_pre_errorFaces_reported_old
          incong_pre_error_miss_num <- num_pre_errorFaces_reported_new
          pre_error_hitRate <- (incong_pre_error_hit_num) / ((incong_pre_error_hit_num) + incong_pre_error_miss_num) # hit rate

          incong_post_error_hit_num <- num_post_errorFaces_reported_old
          incong_post_error_miss_num <- num_post_errorFaces_reported_new
          post_error_hitRate <- (incong_post_error_hit_num) / ((incong_post_error_hit_num) + incong_post_error_miss_num) # hit rate
          # For later, we need to have the following value in main_df:
          num_post_error_faces <- 0
          for (rr in 1:nrow(legit_error_incong_flankerDat)){
            temp_face <- legit_error_incong_flankerDat$post_trial_face[rr] # select post-error faces
            temp_for_surp <- filter(surprise_df, face == temp_face)
            errorFace_exist_in_surpDat <- ifelse(nrow(temp_for_surp) == 1, 1,0)
            if (errorFace_exist_in_surpDat == 1){
              num_post_error_faces <- num_post_error_faces + 1
            }
          } # Closing the loop that counts the number of num_post_error_faces available in surprise_df!

          #### filling the main data frame
          main_df[nrow(main_df) + 1,] <-c(participant_id, congAcc, incongAcc,
                                          incongruent_dat_meanRT, errorDat_meanRT, congruent_dat_meanRT, corrDat_meanRT,
                                          congCorr_meanRT, incongCorr_meanRT, congCorr_logMeanRT,
                                          congErr_meanRT, incongErr_meanRT, congErr_logMeanRT, incongErr_logMeanRT,
                                          incongCorr_logMeanRT, flankEff_meanACC, flankEff_meanRT, flankEff_logMeanRT,
                                          reported_errors, committed_errors, memoryBias_score, overall_hitRate, error_hitRate,
                                          correct_hitRate, post_correct_hitRate, pre_correct_hitRate,
                                          pre_error_hitRate, post_error_hitRate, num_pre_correctFaces_reported_new, num_pre_correctFaces_reported_old,
                                          num_pre_errorFaces_reported_new, num_pre_errorFaces_reported_old,
                                          num_post_correctFaces_reported_new, num_post_correctFaces_reported_old,
                                          num_post_errorFaces_reported_new, num_post_errorFaces_reported_old,
                                          num_incong_correctFaces_reported_new, num_incong_correctFaces_reported_old,
                                          num_incong_errorFaces_reported_new, num_incong_errorFaces_reported_old, hit_num, false_alrams_num,
                                          miss_num, corr_rej_num, incong_error_hit_num, incong_pre_error_hit_num, incong_post_error_hit_num,
                                          incong_correct_hit_num, incong_pre_correct_hit_num, incong_post_correct_hit_num, incong_error_miss_num,
                                          incong_pre_error_miss_num, incong_post_error_miss_num,
                                          incong_correct_miss_num, incong_pre_correct_miss_num, incong_post_correct_miss_num, num_post_error_faces)


        } else { # If a participant has been excluded because they had less than 8 legit incong error faces in the surprise memory task, we add 1 to the counter below.
          num_participants_removed_based_on_num_incong_error_faces_in_memory_surp <- num_participants_removed_based_on_num_incong_error_faces_in_memory_surp + 1
        }
      } else { # If a participant has been excluded because they had less than 8 legit incong errors, we add 1 to the counter below.
        num_of_participants_removed_based_on_incong_error_num <- num_of_participants_removed_based_on_incong_error_num + 1
      }
    } else { # If a participant has been excluded because they had less than 60% flanker accuracy, we add 1 to the counter below.
      num_of_participants_removed_based_on_accuracy <- num_of_participants_removed_based_on_accuracy + 1
    }
  } else { # If a participant has been excluded because they had more than 20% surp trial removed, we add 1 to the counter below.
    num_of_participants_removed_based_on_memory_surp_trial_removal <- num_of_participants_removed_based_on_memory_surp_trial_removal + 1
  }
} # Closing the loop for each participant


for (ee in 1:nrow(main_df)){
  main_df$hitRate_error_minus_correct[ee] <- main_df$error_hitRate[ee] - main_df$correct_hitRate[ee]
  main_df$hitRate_post_error_minus_correct[ee] <- main_df$post_error_hitRate[ee] - main_df$post_correct_hitRate[ee]
}

### Loading RedCap questionnaire data
redcapDat <- read.csv(file = "/Users/kihossei/OneDrive - Florida International University/Projects/Memory_for_error/redcap_data_from_sfe/202203v0socialflanke_SCRD_2022-09-23_1133.csv")

# Keeping the columns that we need!
redcapDat <- redcapDat[c("record_id", "demo_c_yob_s1_r1_e1", "scaared_b_scrdSoc_s1_r1_e1", "scaared_b_scrdGA_s1_r1_e1", "scaared_b_scrdTotal_s1_r1_e1", "bfne_b_scrdTotal_s1_r1_e1")]

# adding new columns to the "percent_mainDat" dataframe from redcapDat
for (rr in 1:nrow(main_df)){
  temp_id <- main_df$participant_id[rr]
  tempDat <- filter(redcapDat, record_id == temp_id)
  if (nrow(tempDat) == 1){
    main_df$scaared_b_scrdSoc_s1_r1_e1[rr] <- tempDat$scaared_b_scrdSoc_s1_r1_e1
    main_df$scaared_b_scrdGA_s1_r1_e1[rr] <- tempDat$scaared_b_scrdGA_s1_r1_e1
    main_df$scaared_b_scrdTotal_s1_r1_e1[rr] <- tempDat$scaared_b_scrdTotal_s1_r1_e1
    main_df$bfne_b_scrdTotal_s1_r1_e1[rr] <- tempDat$bfne_b_scrdTotal_s1_r1_e1
    main_df$demo_c_yob_s1_r1_e1[rr] <- tempDat$demo_c_yob_s1_r1_e1
  } else if (nrow(tempDat) == 0){
    main_df$scaared_b_scrdSoc_s1_r1_e1[rr] <- NA
    main_df$scaared_b_scrdGA_s1_r1_e1[rr] <- NA
    main_df$scaared_b_scrdTotal_s1_r1_e1[rr] <- NA
    main_df$bfne_b_scrdTotal_s1_r1_e1[rr] <- NA
    main_df$demo_c_yob_s1_r1_e1[rr] <- NA
  }
}


### Loading EEG ERP data
eeg_ern <- read.csv(file = "/Users/kihossei/Documents/GitHub/memory-for-error-mini/derivatives/eeg/eeg_erp_output/mini_mfe_erpDat_ern_compMeans.csv")

# Keeping the columns that we need!
eeg_ern <- eeg_ern[c("id", "ERN", "CRN", "deltaERN")]

# adding new columns to the "percent_mainDat" dataframe from eeg_erp
for (rr in 1:nrow(main_df)){
  temp_id <- main_df$participant_id[rr]
  tempDat <- filter(eeg_ern, id == temp_id)
  if (nrow(tempDat) == 1){
    main_df$ERN[rr] <- tempDat$ERN
    main_df$CRN[rr] <- tempDat$CRN
    main_df$deltaERN[rr] <- tempDat$deltaERN
  } else if (nrow(tempDat) == 0){
    main_df$ERN[rr] <- NA
    main_df$CRN[rr] <- NA
    main_df$deltaERN[rr] <- NA
  }
}



##########################################################################################################################
#################### Theta MFC
### Loading EEG Theta power data
eeg_theta_power_mfc250 <- read.csv(file = "/Users/kihossei/Documents/GitHub/memory-for-error-mini/derivatives/eeg/TF_outputs/csv_for_stat/theta/MFC/250/theta_power.csv")

# Keeping the columns that we need!
eeg_theta_power_mfc250 <- eeg_theta_power_mfc250[c("id", "incong_error_theta_power", "incong_correct_theta_power", "difference_score")]

# adding new columns to the "main_df" dataframe from eeg_erp
for (rr in 1:nrow(main_df)){
  temp_id <- main_df$participant_id[rr]
  tempDat <- filter(eeg_theta_power_mfc250, id == temp_id)
  if (nrow(tempDat) == 1){
    main_df$incong_error_theta_power_mfc250[rr] <- tempDat$incong_error_theta_power
    main_df$incong_correct_theta_power_mfc250[rr] <- tempDat$incong_correct_theta_power
    main_df$theta_power_mfc250_difference_score[rr] <- tempDat$difference_score
  } else if (nrow(tempDat) == 0){
    main_df$incong_error_theta_power_mfc250[rr] <- NA
    main_df$incong_correct_theta_power_mfc250[rr] <- NA
    main_df$theta_power_mfc250_difference_score[rr] <- NA
  }
}


### Loading EEG ITPS data
eeg_theta_ITPS_mfc250 <- read.csv(file = "/Users/kihossei/Documents/GitHub/memory-for-error-mini/derivatives/eeg/TF_outputs/csv_for_stat/theta/MFC/250/ITPS.csv")

# Keeping the columns that we need!
eeg_theta_ITPS_mfc250 <- eeg_theta_ITPS_mfc250[c("id", "incong_error_ITPS", "incong_correct_ITPS", "difference_score")]

# adding new columns to the "main_df" dataframe from eeg_erp
for (rr in 1:nrow(main_df)){
  temp_id <- main_df$participant_id[rr]
  tempDat <- filter(eeg_theta_ITPS_mfc250, id == temp_id)
  if (nrow(tempDat) == 1){
    main_df$incong_error_theta_ITPS_mfc250[rr] <- tempDat$incong_error_ITPS
    main_df$incong_correct_theta_ITPS_mfc250[rr] <- tempDat$incong_correct_ITPS
    main_df$theta_ITPS_mfc250_difference_score[rr] <- tempDat$difference_score
  } else if (nrow(tempDat) == 0){
    main_df$incong_error_theta_ITPS_mfc250[rr] <- NA
    main_df$incong_correct_theta_ITPS_mfc250[rr] <- NA
    main_df$theta_ITPS_mfc250_difference_score[rr] <- NA
  }
}



#################### Theta Posterior
### Loading EEG Theta power data
eeg_theta_power_posterior250 <- read.csv(file = "/Users/kihossei/Documents/GitHub/memory-for-error-mini/derivatives/eeg/TF_outputs/csv_for_stat/theta/posterior/250/theta_power.csv")

# Keeping the columns that we need!
eeg_theta_power_posterior250 <- eeg_theta_power_posterior250[c("id", "incong_error_theta_power", "incong_correct_theta_power", "difference_score")]

# adding new columns to the "main_df" dataframe from eeg_erp
for (rr in 1:nrow(main_df)){
  temp_id <- main_df$participant_id[rr]
  tempDat <- filter(eeg_theta_power_posterior250, id == temp_id)
  if (nrow(tempDat) == 1){
    main_df$incong_error_theta_power_posterior250[rr] <- tempDat$incong_error_theta_power
    main_df$incong_correct_theta_power_posterior250[rr] <- tempDat$incong_correct_theta_power
    main_df$theta_power_posterior250_difference_score[rr] <- tempDat$difference_score
  } else if (nrow(tempDat) == 0){
    main_df$incong_error_theta_power_posterior250[rr] <- NA
    main_df$incong_correct_theta_power_posterior250[rr] <- NA
    main_df$theta_power_posterior250_difference_score[rr] <- NA
  }
}



### Loading EEG ITPS data
eeg_theta_ITPS_posterior250 <- read.csv(file = "/Users/kihossei/Documents/GitHub/memory-for-error-mini/derivatives/eeg/TF_outputs/csv_for_stat/theta/posterior/250/ITPS.csv")

# Keeping the columns that we need!
eeg_theta_ITPS_posterior250 <- eeg_theta_ITPS_posterior250[c("id", "incong_error_ITPS", "incong_correct_ITPS", "difference_score")]

# adding new columns to the "main_df" dataframe from eeg_erp
for (rr in 1:nrow(main_df)){
  temp_id <- main_df$participant_id[rr]
  tempDat <- filter(eeg_theta_ITPS_posterior250, id == temp_id)
  if (nrow(tempDat) == 1){
    main_df$incong_error_theta_ITPS_posterior250[rr] <- tempDat$incong_error_ITPS
    main_df$incong_correct_theta_ITPS_posterior250[rr] <- tempDat$incong_correct_ITPS
    main_df$theta_ITPS_posterior250_difference_score[rr] <- tempDat$difference_score
  } else if (nrow(tempDat) == 0){
    main_df$incong_error_theta_ITPS_posterior250[rr] <- NA
    main_df$incong_correct_theta_ITPS_posterior250[rr] <- NA
    main_df$theta_ITPS_posterior250_difference_score[rr] <- NA
  }
}



### Loading EEG wPLI data
eeg_theta_wPLI_posterior250 <- read.csv(file = "/Users/kihossei/Documents/GitHub/memory-for-error-mini/derivatives/eeg/TF_outputs/csv_for_stat/theta/wPLI/posterior/wPLI.csv")

# Keeping the columns that we need!
eeg_theta_wPLI_posterior250 <- eeg_theta_wPLI_posterior250[c("id", "incong_error_wPLI", "incong_correct_wPLI", "difference_score")]

# adding new columns to the "main_df" dataframe from eeg_erp
for (rr in 1:nrow(main_df)){
  temp_id <- main_df$participant_id[rr]
  tempDat <- filter(eeg_theta_wPLI_posterior250, id == temp_id)
  if (nrow(tempDat) == 1){
    main_df$incong_error_theta_wPLI_posterior250[rr] <- tempDat$incong_error_wPLI
    main_df$incong_correct_theta_wPLI_posterior250[rr] <- tempDat$incong_correct_wPLI
    main_df$theta_wPLI_posterior250_difference_score[rr] <- tempDat$difference_score
  } else if (nrow(tempDat) == 0){
    main_df$incong_error_theta_wPLI_posterior250[rr] <- NA
    main_df$incong_correct_theta_wPLI_posterior250[rr] <- NA
    main_df$theta_wPLI_posterior250_difference_score[rr] <- NA
  }
}

####################################################################
# Removing outliers for variables of interest
# list of variables of interest: memoryBias_score, d_prime_error, d_prime_correct, post_d_prime_error, post_d_prime_correct, scaared_b_scrdSoc_s1_r1_e1, scaared_b_scrdTotal_s1_r1_e1, scaared_b_scrdGA_s1_r1_e1, d_prime_error_minus_correct ,post_d_prime_error_minus_correct, unfriendly_error_minus_correct, unfriendly_post_error_minus_correct!
mean_memoryBias_score <- mean(as.numeric(main_df$memoryBias_score), na.rm = TRUE)
sd_memoryBias_score_threeTimes <- 3*sd(as.numeric(main_df$memoryBias_score), na.rm = TRUE)

for (zesht4 in 1:nrow(main_df)){
  if (!is.na(as.numeric(main_df$memoryBias_score[zesht4])) && !is.na(as.numeric(main_df$error_hitRate[zesht4])) && !is.na(as.numeric(main_df$correct_hitRate[zesht4])) && !is.na(as.numeric(main_df$hitRate_error_minus_correct[zesht4])) && !is.na(as.numeric(main_df$hitRate_post_error_minus_correct[zesht4])) && !is.na(as.numeric(main_df$post_error_hitRate[zesht4])) && !is.na(as.numeric(main_df$post_correct_hitRate[zesht4])) && !is.na(as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1[zesht4])) && !is.na(as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1[zesht4])) && !is.na(as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1[zesht4])) && !is.na(as.numeric(main_df$hitRate_error_minus_correct[zesht4])) && !is.na(as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1[zesht4]))){
    if (as.numeric(main_df$memoryBias_score[zesht4]) >= (mean_memoryBias_score - sd_memoryBias_score_threeTimes) && as.numeric(main_df$memoryBias_score[zesht4]) <= (mean_memoryBias_score + sd_memoryBias_score_threeTimes)){
      main_df$memoryBias_score[zesht4] <- as.numeric(main_df$memoryBias_score[zesht4])
    } else {
      main_df$memoryBias_score[zesht4] <- NA
    }

    if (as.numeric(main_df$error_hitRate[zesht4]) >= (mean(as.numeric(main_df$error_hitRate), na.rm = TRUE) - (3*sd(as.numeric(main_df$error_hitRate), na.rm = TRUE))) && as.numeric(main_df$error_hitRate[zesht4]) <= (mean(as.numeric(main_df$error_hitRate), na.rm = TRUE) + (3*sd(as.numeric(main_df$error_hitRate), na.rm = TRUE)))){
      main_df$error_hitRate[zesht4] <- as.numeric(main_df$error_hitRate[zesht4])
    } else {
      main_df$error_hitRate[zesht4] <- NA
    }

    if (as.numeric(main_df$correct_hitRate[zesht4]) >= (mean(as.numeric(main_df$correct_hitRate), na.rm = TRUE) - (3*sd(as.numeric(main_df$correct_hitRate), na.rm = TRUE))) && as.numeric(main_df$correct_hitRate[zesht4]) <= (mean(as.numeric(main_df$correct_hitRate), na.rm = TRUE) + (3*sd(as.numeric(main_df$correct_hitRate), na.rm = TRUE)))){
      main_df$correct_hitRate[zesht4] <- as.numeric(main_df$correct_hitRate[zesht4])
    } else {
      main_df$correct_hitRate[zesht4] <- NA
    }

    if (as.numeric(main_df$post_error_hitRate[zesht4]) >= (mean(as.numeric(main_df$post_error_hitRate), na.rm = TRUE) - (3*sd(as.numeric(main_df$post_error_hitRate), na.rm = TRUE))) && as.numeric(main_df$post_error_hitRate[zesht4]) <= (mean(as.numeric(main_df$post_error_hitRate), na.rm = TRUE) + (3*sd(as.numeric(main_df$post_error_hitRate), na.rm = TRUE)))){
      main_df$post_error_hitRate[zesht4] <- as.numeric(main_df$post_error_hitRate[zesht4])
    } else {
      main_df$post_error_hitRate[zesht4] <- NA
    }

    if (as.numeric(main_df$post_correct_hitRate[zesht4]) >= (mean(as.numeric(main_df$post_correct_hitRate), na.rm = TRUE) - (3*sd(as.numeric(main_df$post_correct_hitRate), na.rm = TRUE))) && as.numeric(main_df$post_correct_hitRate[zesht4]) <= (mean(as.numeric(main_df$post_correct_hitRate), na.rm = TRUE) + (3*sd(as.numeric(main_df$post_correct_hitRate), na.rm = TRUE)))){
      main_df$post_correct_hitRate[zesht4] <- as.numeric(main_df$post_correct_hitRate[zesht4])
    } else {
      main_df$post_correct_hitRate[zesht4] <- NA
    }

    if (as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1[zesht4]) >= (mean(as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1), na.rm = TRUE) - (3*sd(as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1), na.rm = TRUE))) && as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1[zesht4]) <= (mean(as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1), na.rm = TRUE) + (3*sd(as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1), na.rm = TRUE)))){
      main_df$scaared_b_scrdSoc_s1_r1_e1[zesht4] <- as.numeric(main_df$scaared_b_scrdSoc_s1_r1_e1[zesht4])
    } else {
      main_df$scaared_b_scrdSoc_s1_r1_e1[zesht4] <- NA
    }

    if (as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1[zesht4]) >= (mean(as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1), na.rm = TRUE) - (3*sd(as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1), na.rm = TRUE))) && as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1[zesht4]) <= (mean(as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1), na.rm = TRUE) + (3*sd(as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1), na.rm = TRUE)))){
      main_df$scaared_b_scrdTotal_s1_r1_e1[zesht4] <- as.numeric(main_df$scaared_b_scrdTotal_s1_r1_e1[zesht4])
    } else {
      main_df$scaared_b_scrdTotal_s1_r1_e1[zesht4] <- NA
    }

    if (as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1[zesht4]) >= (mean(as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1), na.rm = TRUE) - (3*sd(as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1), na.rm = TRUE))) && as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1[zesht4]) <= (mean(as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1), na.rm = TRUE) + (3*sd(as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1), na.rm = TRUE)))){
      main_df$scaared_b_scrdGA_s1_r1_e1[zesht4] <- as.numeric(main_df$scaared_b_scrdGA_s1_r1_e1[zesht4])
    } else {
      main_df$scaared_b_scrdGA_s1_r1_e1[zesht4] <- NA
    }
    if (as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1[zesht4]) >= (mean(as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1), na.rm = TRUE) - (3*sd(as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1), na.rm = TRUE))) && as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1[zesht4]) <= (mean(as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1), na.rm = TRUE) + (3*sd(as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1), na.rm = TRUE)))){
      main_df$bfne_b_scrdTotal_s1_r1_e1[zesht4] <- as.numeric(main_df$bfne_b_scrdTotal_s1_r1_e1[zesht4])
    } else {
      main_df$bfne_b_scrdTotal_s1_r1_e1[zesht4] <- NA
    }
    if (as.numeric(main_df$hitRate_error_minus_correct[zesht4]) >= (mean(as.numeric(main_df$hitRate_error_minus_correct), na.rm = TRUE) - (3*sd(as.numeric(main_df$hitRate_error_minus_correct), na.rm = TRUE))) && as.numeric(main_df$hitRate_error_minus_correct[zesht4]) <= (mean(as.numeric(main_df$hitRate_error_minus_correct), na.rm = TRUE) + (3*sd(as.numeric(main_df$hitRate_error_minus_correct), na.rm = TRUE)))){
      main_df$hitRate_error_minus_correct[zesht4] <- as.numeric(main_df$hitRate_error_minus_correct[zesht4])
    } else {
      main_df$hitRate_error_minus_correct[zesht4] <- NA
    }

    if (as.numeric(main_df$hitRate_post_error_minus_correct[zesht4]) >= (mean(as.numeric(main_df$hitRate_post_error_minus_correct), na.rm = TRUE) - (3*sd(as.numeric(main_df$hitRate_post_error_minus_correct), na.rm = TRUE))) && as.numeric(main_df$hitRate_post_error_minus_correct[zesht4]) <= (mean(as.numeric(main_df$hitRate_post_error_minus_correct), na.rm = TRUE) + (3*sd(as.numeric(main_df$hitRate_post_error_minus_correct), na.rm = TRUE)))){
      main_df$hitRate_post_error_minus_correct[zesht4] <- as.numeric(main_df$hitRate_post_error_minus_correct[zesht4])
    } else {
      main_df$hitRate_post_error_minus_correct[zesht4] <- NA
    }
  }
}


# Replacing NAs for pre/post error/correct hitRAtes, d's when they are less than 8 (i.e, cutoff for the number of incongruent errors)!
# The correct way is to do this for post-correct ones too. However, we already that is not an issue for this dataset. So, I do this just for post-error ones.
# I don't do this for pre- ones, as I don't run stats on them.
for (j in 1:nrow(main_df)){
  if (is.na(main_df$num_post_error_faces[j]) || main_df$num_post_error_faces[j] < 8 ){
    main_df$post_error_hitRate[j] <- NA
    main_df$post_d_prime_error[j] <- NA
  }
}
####################
# Save the dataset
# write the extracted and computed summary scores to disk
write.csv(main_df, paste(output_path, proc_fileName, sep = "/", collapse = NULL), row.names=FALSE)
##################

